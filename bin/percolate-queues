#!/usr/bin/env ruby

require 'rubygems'
require 'yaml'
require 'optparse'
require 'beanstalk-client'

class QueueClientArguments < Hash
  def initialize args
    super

    self[:host] = 'localhost'
    self[:port] = 11300

    opts = OptionParser.new { |opts|
      opts.banner = "Usage: #$0 [options]"

      opts.on('-h', '--host [HOSTNAME]',
              'Percolate queue host, default localhost') { |host|
        self[:host] = host
      }

      opts.on('-p', '--port [PORT]',
              'Percolate queue port, default 11300') { |port|
        begin
          if port
            self[:port] = Integer(port)
          end
        rescue ArgumentError => ae
          raise OptionParser::ParseError, ae.to_s
        end
      }

      opts.on('-d', '--drain QUEUE', 'Drain queue') { |drain|
        self[:drain] = drain
      }

      opts.on('-?', '--help', 'Display this help and exit') {
        $stderr.puts(opts)
        exit
      }
    }

    begin
      opts.parse!(args)
    rescue Exception => e
      $stderr.puts(opts)
      $stderr.puts("\nCommand line error: #{e.message}")
      exit(10)
    end

    self
  end
end

def host_id args
  "#{args[:host]}:#{args[:port]}"
end

def queue_stats client
  # puts client.raw_stats.inspect
  puts("Current-connections: #{client.stats['current-connections']}\n\n")
  queues = client.list_tubes

  # puts "Queues: #{queues.inspect}"

  queues.keys.each { |key|
    queues[key].each { |queue|
      puts("Queue: #{queue.inspect}")
      puts("Client stats: #{client.stats_tube(queue).inspect}\n\n")
    }
  }
end

def drain_queue client, host_id, queue
  queues = client.list_tubes[host_id]

  unless queues.include?(queue)
    raise ArgumentError, "No such queue '#{queue}' in #{queues.inspect}"
  end

  client.watch(queue)
  client.use(queue)

  msgs = []

  loop do
    if client.peek_ready
      msg = client.reserve
      msgs << msg.ybody
      msg.delete
    else
      break
    end
  end

  puts(YAML.dump(msgs))
end

args = QueueClientArguments.new(ARGV)
client = Beanstalk::Pool.new(host_id(args))

begin
  if args.has_key?(:drain)
    puts "Draining '#{args[:drain]}'"
    drain_queue(client, host_id(args), args[:drain])
  else
    queue_stats(client)
  end
rescue Exception => e
  $stderr.puts("Error: #{e}")
  exit(10)
ensure
  client.close
end
